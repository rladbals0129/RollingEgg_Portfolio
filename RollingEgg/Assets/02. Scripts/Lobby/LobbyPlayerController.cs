using UnityEngine;
using RollingEgg.UI;

namespace RollingEgg.Lobby
{
    /// <summary>
    /// 로비에서 플레이어를 제어하는 컨트롤러
    /// 좌우 방향키로 이동, 스페이스바로 점프합니다.
    /// </summary>
    public class LobbyPlayerController : MonoBehaviour
    {
        [Header("Movement Settings")]
        [SerializeField] private float _moveSpeed = 5f;
        [SerializeField] private float _jumpForce = 10f;
        [SerializeField] private BoxCollider2D _mapBoundary; // 이동 가능한 맵 영역

        [Header("Ground Check")]
        [SerializeField] private Transform _groundCheck; // 발 위치 체크용
        [SerializeField] private float _groundCheckRadius = 0.2f;
        [SerializeField] private LayerMask _groundLayer; // 땅으로 인식할 레이어
        [SerializeField] private float _groundCheckSkin = 0.05f; // 땅과의 여유 거리

        [Header("Components")]
        private SpriteRenderer _spriteRenderer;
        private Animator _animator;
        private Rigidbody2D _rigidbody2D;
        private Collider2D _collider2D;
        private readonly ContactPoint2D[] _contactBuffer = new ContactPoint2D[8];
        private PhysicsMaterial2D _frictionlessMaterial;

        [Header("Animation Parameters")]
        private static readonly int IsGrounded = Animator.StringToHash("IsGrounded");
        private static readonly int IsRunning = Animator.StringToHash("IsRunning");
        private static readonly int VelocityY = Animator.StringToHash("VelocityY");

        private float _horizontalInput;
        private bool _isFacingRight = true;
        private bool _isGrounded;
        private bool _jumpPressed;
        private bool _autoGeneratedGroundCheck;
        private bool _isInputBlocked;

        private void Awake()
        {
            // 컴포넌트 참조
            _spriteRenderer = GetComponent<SpriteRenderer>();
            _animator = GetComponent<Animator>();
            _rigidbody2D = GetComponent<Rigidbody2D>();
            _collider2D = GetComponent<Collider2D>();

            // Rigidbody2D 설정 확인 (없으면 추가)
            if (_rigidbody2D == null)
            {
                _rigidbody2D = gameObject.AddComponent<Rigidbody2D>();
            }

            if (_collider2D == null)
            {
                _collider2D = gameObject.AddComponent<BoxCollider2D>();
            }

            // Rigidbody2D 설정 (점프를 위해 Dynamic + 중력 사용)
            _rigidbody2D.bodyType = RigidbodyType2D.Dynamic;
            _rigidbody2D.gravityScale = 2f; // 중력 설정
            _rigidbody2D.constraints = RigidbodyConstraints2D.FreezeRotation; // 회전 고정!
            _rigidbody2D.collisionDetectionMode = CollisionDetectionMode2D.Continuous; // 벽/모서리 충돌 안정화

            // 마찰 제거로 벽 끼임 방지
            EnsureFrictionlessMaterial();

            // Ground Check 오브젝트가 없으면 자동 생성
            if (_groundCheck == null)
            {
                GameObject groundCheckObj = new GameObject("GroundCheck");
                groundCheckObj.transform.SetParent(transform);
                _groundCheck = groundCheckObj.transform;
                _groundCheck.localPosition = Vector3.zero;
                _autoGeneratedGroundCheck = true;
            }
            else
            {
                _autoGeneratedGroundCheck = false;
            }

            UpdateAutoGroundCheckPosition();
        }

        private void Update()
        {
            _isInputBlocked = IsInputBlocked();
            if (_isInputBlocked)
            {
                _horizontalInput = 0f;
                _jumpPressed = false;
                UpdateAnimation();
                return;
            }

            HandleInput();
            CheckGround();
            UpdateAnimation();
        }

        private void FixedUpdate()
        {
            Move();
            ClampPosition();
        }

        /// <summary>
        /// 입력 처리 (좌우 이동 + 점프)
        /// </summary>
        private void HandleInput()
        {
            // 좌우 방향키 입력
            _horizontalInput = Input.GetAxisRaw("Horizontal"); // ←/→ 또는 A/D

            // 스페이스바 점프
            if (Input.GetKeyDown(KeyCode.Space) && _isGrounded)
            {
                _jumpPressed = true;
            }

            // 스프라이트 좌우 반전
            if (_horizontalInput > 0 && !_isFacingRight)
            {
                Flip();
            }
            else if (_horizontalInput < 0 && _isFacingRight)
            {
                Flip();
            }
        }

        private bool IsInputBlocked()
        {
            return UIManager.Instance != null && UIManager.Instance.IsPopupActive(UI.EPopupUIType.Collection);
        }

        /// <summary>
        /// 땅에 닿아있는지 체크
        /// </summary>
        private void CheckGround()
        {
            _isGrounded = EvaluateGroundedByContactNormal();
        }

        /// <summary>
        /// 캐릭터 이동 처리
        /// </summary>
        private void Move()
        {
            // 경계 체크 후 이동 가능한 방향만 허용
            float moveVelocity = _horizontalInput * _moveSpeed;

            if (_mapBoundary != null && _horizontalInput != 0)
            {
                Bounds bounds = _mapBoundary.bounds;
                Vector3 pos = transform.position;

                // 왼쪽 경계에 닿았는데 왼쪽으로 이동하려는 경우
                if (pos.x <= bounds.min.x && _horizontalInput < 0)
                {
                    moveVelocity = 0;
                }
                // 오른쪽 경계에 닿았는데 오른쪽으로 이동하려는 경우
                else if (pos.x >= bounds.max.x && _horizontalInput > 0)
                {
                    moveVelocity = 0;
                }
            }

            // 좌우 이동
            _rigidbody2D.linearVelocity = new Vector2(moveVelocity, _rigidbody2D.linearVelocity.y);

            // 점프
            if (_jumpPressed)
            {
                _rigidbody2D.linearVelocity = new Vector2(_rigidbody2D.linearVelocity.x, _jumpForce);
                _jumpPressed = false;
            }
        }

        /// <summary>
        /// 위치를 맵 경계 내로 제한 (Y축만 - 낙하 방지용)
        /// </summary>
        private void ClampPosition()
        {
            if (_mapBoundary == null)
                return;

            Bounds bounds = _mapBoundary.bounds;
            Vector3 pos = transform.position;

            // Y축만 제한 (너무 아래로 떨어지지 않게)
            if (pos.y < bounds.min.y)
            {
                transform.position = new Vector3(pos.x, bounds.min.y, pos.z);
                _rigidbody2D.linearVelocity = new Vector2(_rigidbody2D.linearVelocity.x, 0);
            }
        }

        /// <summary>
        /// 애니메이션 업데이트
        /// </summary>
        private void UpdateAnimation()
        {
            if (_animator == null)
                return;

            // IsGrounded: 땅에 닿아있는지
            _animator.SetBool(IsGrounded, _isGrounded);

            // IsRunning: 좌우로 이동 중인지
            bool isMoving = Mathf.Abs(_horizontalInput) > 0.01f;
            _animator.SetBool(IsRunning, isMoving);

            // VelocityY: 점프/낙하 구분용 (양수면 점프, 음수면 낙하)
            _animator.SetFloat(VelocityY, _rigidbody2D.linearVelocity.y);
        }

        /// <summary>
        /// 스프라이트 좌우 반전
        /// </summary>
        private void Flip()
        {
            _isFacingRight = !_isFacingRight;

            if (_spriteRenderer != null)
            {
                _spriteRenderer.flipX = !_isFacingRight;
            }
        }

        /// <summary>
        /// 맵 경계 설정
        /// </summary>
        public void SetMapBoundary(BoxCollider2D boundary)
        {
            _mapBoundary = boundary;
        }

        /// <summary>
        /// 이동 속도 설정
        /// </summary>
        public void SetMoveSpeed(float speed)
        {
            _moveSpeed = speed;
        }

        /// <summary>
        /// 현재 이동 중인지 여부
        /// </summary>
        public bool IsMoving => Mathf.Abs(_horizontalInput) > 0.01f;

#if UNITY_EDITOR
        /// <summary>
        /// 맵 경계 및 Ground Check 시각화 (에디터 전용)
        /// </summary>
        private void OnDrawGizmosSelected()
        {
            if (_mapBoundary != null)
            {
                Gizmos.color = Color.yellow;
                Gizmos.DrawWireCube(_mapBoundary.bounds.center, _mapBoundary.bounds.size);
            }

            if (_groundCheck != null)
            {
                Gizmos.color = Color.red;
                Vector2 gizmoOrigin = Application.isPlaying
                    ? GetGroundCheckPosition()
                    : GetEditorGroundCheckPosition();
                Gizmos.DrawWireSphere(gizmoOrigin, _groundCheckRadius);
            }
        }
#endif

        /// <summary>
        /// 자동 생성 GroundCheck의 위치를 플레이어 콜라이더 하단에 맞춰 갱신
        /// </summary>
        private void UpdateAutoGroundCheckPosition()
        {
            if (!_autoGeneratedGroundCheck || _groundCheck == null || _collider2D == null)
                return;

            Vector2 worldPoint = ResolveGroundCheckPosition(false);
            Vector3 localPoint = transform.InverseTransformPoint(worldPoint);
            _groundCheck.localPosition = localPoint;
        }

        private Vector2 GetGroundCheckPosition()
        {
            return ResolveGroundCheckPosition(false);
        }

        private Vector2 GetEditorGroundCheckPosition()
        {
            return ResolveGroundCheckPosition(true);
        }

        private Vector2 ResolveGroundCheckPosition(bool allowEditorLookup)
        {
            if (_groundCheck != null && !_autoGeneratedGroundCheck)
            {
                return _groundCheck.position;
            }

            Collider2D sourceCollider = _collider2D;
            if (sourceCollider == null && allowEditorLookup)
            {
                sourceCollider = GetComponent<Collider2D>();
            }

            if (sourceCollider != null)
            {
                Bounds bounds = sourceCollider.bounds;
                float checkY = bounds.min.y - _groundCheckSkin;
                return new Vector2(bounds.center.x, checkY);
            }

            if (_groundCheck != null)
            {
                return _groundCheck.position;
            }

            return transform.position;
        }

        /// <summary>
        /// 접촉 면의 법선값을 기반으로 땅에 닿았는지 판단
        /// (벽 옆면 접촉으로 인한 공중부양 방지)
        /// </summary>
        private bool EvaluateGroundedByContactNormal()
        {
            if (_rigidbody2D == null)
                return false;

            int contactCount = _rigidbody2D.GetContacts(_contactBuffer);
            for (int i = 0; i < contactCount; i++)
            {
                ContactPoint2D contact = _contactBuffer[i];
                if (contact.collider == null)
                    continue;

                bool isGroundLayer = (_groundLayer.value & (1 << contact.collider.gameObject.layer)) != 0;
                if (!isGroundLayer)
                    continue;

                // 바닥에 가까운 접촉만 허용: 위쪽 법선이 x 성분보다 크고 충분히 큰 경우
                bool isUprightEnough = contact.normal.y >= 0.7f && contact.normal.y > Mathf.Abs(contact.normal.x);
                bool isCloseEnough = contact.separation <= _groundCheckSkin + 0.01f;

                if (isUprightEnough && isCloseEnough)
                {
                    return true;
                }
            }

            // 접촉이 없는 경우에도 Gizmo 시각화를 위해 기존 원판 위치 반환을 유지하기 때문에
            // 실제 착지는 접촉 기반으로만 판단
            return false;
        }

        /// <summary>
        /// 콜라이더 마찰 제거 (벽에 달라붙는 현상 완화)
        /// </summary>
        private void EnsureFrictionlessMaterial()
        {
            if (_collider2D == null)
                return;

            if (_frictionlessMaterial == null)
            {
                _frictionlessMaterial = new PhysicsMaterial2D("PlayerFrictionless")
                {
                    friction = 0f,
                    bounciness = 0f
                };
            }

            if (_collider2D.sharedMaterial != _frictionlessMaterial)
            {
                _collider2D.sharedMaterial = _frictionlessMaterial;
            }
        }
    }
}
